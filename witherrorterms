alter this code such that it displays at least 300 digits for each outpuut/string. import decimal
from decimal import Decimal, getcontext
from mpmath import mp

# Set precision
getcontext().prec = 2000
mp.dps = 2000

def refine_e(n):
    n_decimal = Decimal(n)
    
    # Calculate the approximations
    approx_e = ((n_decimal + Decimal(1)) / n_decimal) ** n_decimal
    approx_1_over_e = ((n_decimal - Decimal(1)) / n_decimal) ** n_decimal
    reciprocal_of_1_over_e = Decimal(1) / approx_1_over_e

    # Calculate the difference
    difference = approx_e - reciprocal_of_1_over_e

    # Calculate the absolute value of the difference
    absolute_difference = abs(difference)

    # Convert to string without scientific notation and extract digits
    absolute_difference_str = f"{absolute_difference:.200f}".rstrip('0').rstrip('.')

    # Ensure the string representation starts correctly
    if absolute_difference_str.startswith('0.'):
        absolute_difference_str = absolute_difference_str[2:]

    # Remove all zeros and place a period after the first non-zero digit
    non_zero_index = next(i for i, c in enumerate(absolute_difference_str) if c != '0')
    final_result_str = absolute_difference_str[non_zero_index] + '.' + absolute_difference_str[non_zero_index + 1:]

    # Import the most accurate value of e from mpmath and convert to Decimal
    mp_e = Decimal(str(mp.e))

    # Convert final_result_str to Decimal
    final_result_decimal = Decimal(final_result_str)

    # Calculate the first adjustment term
    x = Decimal(str(mp.log10(n)))
    first_error_term = (Decimal(7) / Decimal(8)) * Decimal(str(mp.e)) * Decimal(10) ** (-2 * x)

    # Subtract the first error term from the final result
    final_adjusted_result_decimal = final_result_decimal - first_error_term

    # Calculate the second adjustment term correctly
    second_error_term = (Decimal(959) / Decimal(1152)) * Decimal(str(mp.e)) * Decimal(10) ** (-4 * x)
    
    # Add the second error term to the final adjusted result
    final_adjusted_result_with_second_term = final_adjusted_result_decimal + second_error_term

    # Subtract e from the final adjusted result
    result_after_subtraction = final_adjusted_result_with_second_term - mp_e

    # Output the results
    print("approx_e:", approx_e)
    print("reciprocal_of_1_over_e:", approx_1_over_e)
    print("difference:", difference)
    print("first_error_term:", first_error_term)
    print("absolute difference without leading zeros, first digit in the ones column:", final_result_str)
    print("final_result_decimal before subtracting error term:", final_result_decimal)
    print("final_adjusted_result_decimal after subtracting first error term:", final_adjusted_result_decimal)
    print("second_error_term:", second_error_term)
    print("final_adjusted_result_with_second_term after adding second error term:", final_adjusted_result_with_second_term)
    print("result after subtracting e:", result_after_subtraction)

# Test the function with n = 10**10
n = 10**10
refine_e(n)
